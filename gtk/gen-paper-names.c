/* GTK - The GIMP Toolkit
 * Copyright (C) 2006 Matthias Clasen
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <glib.h>

#include "paper_names.c"

static const gint n_infos = G_N_ELEMENTS (standard_names);
static const gint n_extra = G_N_ELEMENTS (extra_ppd_names);

typedef struct {
  const gchar *s;
  gboolean nify;
  gint offset;
  gboolean writeout;
} NameInfo;

/* Calculate offsets, also take care of duplicates and strings 
 * which are suffixes of each other. nify indicates that a string
 * must be emitted with the N_() macro, and thus must appear on
 * its own, even if it is a suffix of another string.
 */
static void
add_name (NameInfo    *names, 
	  gint        *n, 
	  const gchar *name, 
	  gboolean     nify)
{
  gint i, nlen, ilen;

  names[*n].s = name;
  names[*n].nify = nify;
  names[*n].writeout = 1;
  if (*n > 0)
    names[*n].offset = names[*n - 1].offset + strlen(names[*n - 1].s) + 1;
  else
    names[*n].offset = 0;

  nlen = strlen (name);
  for (i = 0; i < *n; i++)
    {
      ilen = strlen (names[i].s);

      if (ilen >= nlen)
	{
	  if (strcmp (name, names[i].s + ilen - nlen) == 0)
	    {
	      names[*n].offset = names[i].offset + ilen - nlen;

	      if (ilen == nlen)
		{
		  names[i].nify = names[i].nify || nify;

		  return;
		}
	      else
		{
		  names[*n].writeout = nify;
		  break;
		}
	    }
	}
    }
  
  (*n)++;
}

static gint
find_name (NameInfo    *names, 
	   gint         n_names, 
	   const gchar *name)
{
  gint i;

  if (!name)
    return -1;

  for (i = 0; i < n_names; i++)
    {
      if (strcmp (names[i].s, name) == 0)
	return names[i].offset;
    }

  printf ("BOO! %s not found\n", name);

  return -2;
}

#define MM_PER_INCH 25.4
#define POINTS_PER_INCH 72

static gboolean
parse_media_size (const gchar *size,
		  gdouble     *width_mm, 
		  gdouble     *height_mm)
{
  const gchar *p;
  gchar *e;
  gdouble short_dim, long_dim;

  p = size;
  
  short_dim = g_ascii_strtod (p, &e);

  if (p == e || *e != 'x')
    return FALSE;

  p = e + 1; /* Skip x */

  long_dim = g_ascii_strtod (p, &e);

  if (p == e)
    return TRUE;

  p = e;

  if (strcmp (p, "in") == 0)
    {
      short_dim = short_dim * MM_PER_INCH;
      long_dim = long_dim * MM_PER_INCH;
    }
  else if (strcmp (p, "mm") != 0)
    return FALSE;

  if (width_mm)
    *width_mm = short_dim;
  if (height_mm)
    *height_mm = long_dim;
  
  return TRUE;  
}

int 
main (int argc, char *argv[])
{
  gint i, n_names;
  NameInfo *names;
  gdouble width, height;

  names = (NameInfo *) malloc (sizeof (NameInfo) * (n_infos + n_extra));

  /* collect names */

  n_names = 0;
  for (i = 0; i < n_infos; i++)
    {
      add_name (names, &n_names, standard_names[i].name, FALSE);
      add_name (names, &n_names, standard_names[i].display_name, TRUE);
      if (standard_names[i].ppd_name)
	add_name (names, &n_names, standard_names[i].ppd_name, FALSE);
    }

  for (i = 0; i < n_extra; i++)
    {
      add_name (names, &n_names, extra_ppd_names[i].ppd_name, 0);
      add_name (names, &n_names, extra_ppd_names[i].standard_name, 0);
    }

  /* dump names */

  printf ("/* Generated by gen-paper-names */\n\n"
	  "#ifndef N_\n"
	  "#define N_(s) s\n"
	  "#endif\n\n"
	  "const char paper_names[] =");
  for (i = 0; i < n_names; i++)
    {
      if (names[i].writeout)
	{
	  if (names[i].nify)
	    printf ("\n  N_(\"%s\") \"\\0\"", names[i].s);
	  else
	    printf ("\n  \"%s\\0\"", names[i].s);
	}
    }
  printf (";\n\n");

  /* dump PaperInfo array */
  printf ("typedef struct {\n"
	  "  int name;\n"
	  "  float width;\n"
          "  float height;\n"
	  "  int display_name;\n"
	  "  int ppd_name;\n"
	  "} PaperInfo;\n\n"
          "const PaperInfo standard_names_offsets[] = {\n");

  for (i = 0; i < n_infos; i++)
    {
      width = height = 0.0;
      if (!parse_media_size (standard_names[i].size, &width, &height))
	printf ("failed to parse size %s\n", standard_names[i].size);

      printf ("  { %4d, %g, %g, %4d, %4d },\n", 
	      find_name (names, n_names, standard_names[i].name),
	      width, height,
	      find_name (names, n_names, standard_names[i].display_name),
	      find_name (names, n_names, standard_names[i].ppd_name));
    }
  
  printf ("};\n\n");


  /* dump extras */

  printf ("const struct {\n"
	  "  int ppd_name;\n"
	  "  int standard_name;\n"
	  "} extra_ppd_names_offsets[] = {\n");

  for (i = 0; i < n_extra; i++)
    {
      printf ("  { %4d, %4d },\n", 
	      find_name (names, n_names, extra_ppd_names[i].ppd_name),
	      find_name (names, n_names, extra_ppd_names[i].standard_name));
    }
  
  printf ("};\n\n");

  return 0;
}
